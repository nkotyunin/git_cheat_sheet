# GIT Cheat Sheet

## Создание репозитория
- Инициализировать репозиторий можно с помощью команды **git init**.
- Проверить статус, или состояние, репозитория поможет команда **git status**.
- Если вы ошиблись и случайно инициализировали не ту папку, можно «разгитить» её — удалить скрытую подпапку **.git**.

## Добавление файлов в репозиторий
- Команда **git add** позволяет подготовить файл к сохранению.
- Команда **git add --all** подготовит к сохранению сразу все файлы.
- С помощью **git add .** можно добавить в репозиторий текущую папку со всеми файлами.

## GIT Commit
- Коммит можно сделать с помощью команды *git commit*.
- Ключ **-m** позволяет присвоить коммиту сообщение. Помните, что такие сообщения должны быть информативными: чётко описывать изменения.
- В коммит попадает то, что было предварительно добавлено «в корзину», или «в кадр», перед коммитом.

## История коммитов
Для просмотра истории коммитов используют команду **git log** (от англ. log — «журнал»).

Получить сокращённый лог можно с помощью команды git log с флагом **--oneline** (англ. «одной строкой»). В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.

## SSH-ключ и его генерация
- *SSH* — протокол, который обеспечивает безопасный обмен данными в сети и использует для этого ключи.
- *SSH-ключ* — ваш виртуальный идентификатор в GitHub. Как ключ от квартиры, он позволяет получить доступ к GitHub-репозиторию. Также SSH используется для доступа к другим удалённым серверам.
- *SSH-ключ состоит из двух частей* — публичной и приватной. Публичный ключ зашифрует данные, а приватный — расшифрует. Приватным ключом ни в коем случае нельзя делиться, иначе любой сможет расшифровать все ваши секреты!

Для генерации SSH-ключа используют команды:

**$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"**

или

**$ ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"**


После создания SSH-ключа его необходимо привязать к аккаунту GitHub, [здесь](https://practicum.yandex.ru/trainer/git-basics/lesson/4d662a58-3602-4c5c-9fad-be8cff334f37/) можно посмотреть инструкцию.

## Связка локального и удаленного репозиториев
Чтобы привязать удаленный репозиторий к локальному, используют команду **git remote add**. Пример использования команды:

**$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git** ,

где *origin* - (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один), а *git@github.com:%ИМЯ_АККАУНТА%/first-project.git* - SSH-ссылка на удаленный репозиторий.

Для проверки связки репозиториев используется команда **git remote -v**.

*$ git remote -v*

*origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)*

*origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)*

Вывод должен быть аналогичен, указанному выше.

Флаг *-v* — короткая форма флага *--verbose* (англ. «подробный»). Он позволяет показать больше информации в выводе.

## Синхронизация локального и удаленного репозиториев
За отправку изменений на удалённый репозиторий отвечает команда **git push**. В первый раз эту команду нужно вызвать с флагом *-u* и параметрами *origin* (имя удалённого репозитория) и *main* или *master* (название текущей ветки). Флаг *-u* свяжет локальную ветку с одноимённой удалённой.

**$ git push -u origin main** *# Если команда приведёт к ошибке, попробуйте*
                              *# заменить main на master.*

В дальнейшем при работе с удалённым репозиторием флаг *-u* можно опустить и писать просто **git push**.

## Оформление файла README.md
Как правило, в **README.md** проекта можно найти следующую информацию:
- Название проекта и его краткое описание: кем создан, для чего, какие решает задачи и какие закрывает проблемы.
- Технологии, которые применяются в проекте. В чём его отличие от аналогичных.
- Документация проекта — подробная инструкция о том, что представляет собой проект.
- Планы проекта, если они есть.

Вот *пример файла README.md* для Git [на GitHub](https://github.com/git/git/blob/master/README.md).

**Преимущество README.md** в том, что средства командной работы (такие, как GitHub) могут отображать его содержимое в браузере в виде удобной разметки. Для этого нужно не просто залить текст, но и настроить шрифт, заголовки и отступы с помощью markdown. **Маркда́ун** — это специальный язык разметки. Он позволяет красиво отформатировать текстовый документ. Базовый синтаксис языка можно посмотреть [здесь](https://doka.guide/tools/markdown/).

## Хеш — идентификатор коммита
- Git преобразует информацию о коммитах с помощью алгоритма *SHA-1* и для каждого из них рассчитывает уникальный идентификатор — *хеш*.
- *Хеш* — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов.
- Все хеши, а также таблицу соответствий *хеш → информация* о коммите Git хранит в папке *.git*.

В числе прочих файлов в папке *.git* есть служебный файл **HEAD**. Он указывает на самый свежий коммит. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово **HEAD** — Git поймёт, что вы имели в виду последний коммит.

## Статусы файлов в Git
- Статусом **untracked** помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность **tracked**, в который попадают все файлы, отслеживаемые Git.
- Файл переходит в статус **staged** (синонимы - indexed и cached) после выполнения *git add*.
- Статус **modified** означает, что файл был изменён.
- Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.

## Правила по оформлению сообщений к коммитам

- **Краткость и ясность**: Сообщение коммита должно быть кратким и содержательным. Оно должно ясно передавать суть внесенных изменений.
- **Используйте повелительное наклонение**: Начните сообщение с глагола в повелительном наклонении. Например, "Add", "Fix", "Update", "Remove" и т.д. Это поможет ясно указать, что делает этот коммит.
- **Не используйте завершающие точки**: Они не нужны и могут создать несогласованность с другими сообщениями коммитов.
- **Описывайте изменения**: После заголовка, добавьте пустую строку, а затем короткое описание того, что именно было изменено. Это может быть необязательно, но если изменение не очевидно из заголовка, полезно добавить дополнительное пояснение.
- **Ссылка на задачу** (если есть): Если ваш проект использует систему управления задачами (например, Jira, Trello, GitHub Issues), хорошей практикой является добавление ссылки на соответствующую задачу в сообщение коммита. Например: "Add feature X (fixes #123)".
- **Избегайте коммитов слишком большого объема**: Лучше разбивать большие изменения на несколько более мелких и независимых коммитов. Это делает историю изменений более читаемой и позволяет более легко откатывать или возвращаться к определенным изменениям.
- **Используйте настоящее время**: Сообщение коммита должно описывать изменения так, будто они уже внесены, используя настоящее время.
- **Избегайте лишних деталей**: В сообщении коммита не следует добавлять слишком много деталей, которые не имеют отношения к сути изменений.

Более подробные требования к оформлению сообщений к коммитам можно посмотреть [здесь](https://practicum.yandex.ru/trainer/git-basics/lesson/1add1d42-16f2-4df3-b230-d3362e10acb8/).

## Исправление последнего коммита
Можно внести правки в уже сделанный коммит с помощью опции **--amend** (от англ. amend — «исправить», «дополнить») у команды *commit*: **git commit --amend**.

Важно: опция **--amend** работает только с последним коммитом (*HEAD*). Для исправления более ранних коммитов есть другие команды.

Дополнить коммит новыми файлами можно с помощью **git commit --amend --no-edit**. Благодаря опции **--no-edit** сообщение к коммиту останется таким, каким и было.

Изменить сообщение к коммиту позволяет команда **git commit --amend -m "Обновлённое сообщение коммита"**.

## Откат файлов и коммитов до более ранних версий
Команда **git restore --staged "имя файла"** переведёт файл из *staged* обратно в *modified* или *untracked*.

Команда **git reset --hard "commit hash"** «откатит» историю до коммита с хешем **"hash"**. Более поздние коммиты будут безвозвратно удалены.

Команда **git restore "имя файла"** «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии.

## Просмотр изменений
- Команда **git diff** сравнит последнюю закоммиченную версию файла с той, что находится в состоянии modified.
- Команда **git diff --staged** покажет изменения в staged-файлах относительно последних закоммиченных версий.
- С помощью команды **git diff "коммит1" "коммит2"** можно сравнивать изменения в двух коммитах.
- **git diff** может сравнивать ветки по их названиям. Например, команда **git diff main feature/my-feature** выведет разницу между основной веткой и веткой *feature/my-feature*.
- Git поддерживает суффикс навигации **~**. С его помощью можно сослаться на предыдущие коммиты. Например, если вы находитесь в ветке main и хотите вывести разницу между тем коммитом, который был три коммита назад, и текущим, нужно выполнить **git diff main~3 main**.

## Игнорирование файлов в Git
- Если нужно, чтобы Git игнорировал какие-то файлы, стоит составить файл **.gitignore**.
- Посмотреть, что игнорируется, можно с помощью команды **git status --ignored**.
- Сам файл **.gitignore** — это обычный файл в репозитории. Его тоже стоит закоммитить.
- Шаблонов много, но их легко найти в интернете вместе с примерами использования.

## Клонирование репозиториев
- Команда **git clone** копирует проект на локальный компьютер.
- **git clone** автоматически связывает локальный репозиторий с удалённым.

## «Форк» удаленных репозиториев
- «Форк» позволяет получить точную копию GitHub-репозитория в ваш аккаунт.
- Копия, которая получена с помощью «форка», полностью независима от оригинального проекта — изменения не будут синхронизированы.

Обычно комбинация «форк» + **clone** используется для внесения изменений в публичные репозитории. В этом случае «форк» становится подготовительным этапом перед клонированием чужого репозитория на ваш компьютер.

Если репозиторий приватный или это репозиторий вашей компании, при работе с ним достаточно **clone**.

## Ветки GIT
- Ветка — это последовательность независимых изменений.
- Благодаря веткам несколько человек могут работать над одним репозиторием и не мешать друг другу. А ещё ветки помогают декомпозировать большую и страшную задачу на маленькие и понятные.
- Основная версия проекта хранится в главной ветке **main** (или master).
- С помощью команды **git branch** можно посмотреть, какие в проекте есть ветки и в какой из них вы сейчас находитесь.
- Новые ветки в проекте можно создавать с помощью команды **git branch "название_ветки"**.
- Для переключения на другую ветку используется команда **git checkout "название_ветки"**.
- Команда **git checkout "название_ветки"** позволяет переключаться на другую ветку.
- Разные ветки в одном проекте существуют независимо. Изменения в одной не влияют на изменения в другой.
- В Git можно создать ветку и сразу же перейти в неё командой **git checkout -b "название_ветки"**.
- Ветка указывает на коммит, который сделан в ней последним. При этом две ветки могут ссылаться на один и тот же коммит — например, если вы только что создали ветку, но ещё не успели внести в неё коммит.

## Слияние веток
- Выполнить слияние веток позволяет команда **git merge "название_ветки"**. В качестве параметра указывают название ветки, которую нужно влить в текущую.
- Удалять ненужные ветки после слияния — хорошая практика. Так в вашем репозитории всегда будет порядок. За удаление веток отвечает команда **git branch -D "название_ветки"** и её щадящий вариант с флагом **-d**.

## Pull request
- Пул-реквест — это запрос на рассмотрение предлагаемых изменений и часть процесса ревью.
- Запрос на изменения можно инициировать двумя способами: через ссылку, которую Git выводит после создания ветки, или через интерфейс GitHub.
- После создания пул-реквеста ваши коллеги сделают ревью — оценят предложенные вами правки и оставят свои комментарии.
- По результатам ревью ваши правки могут быть приняты в основную ветку проекта или возвращены на доработку.

## GIT Pull
- Команда **git pull** позволяет подтянуть изменения из удалённого репозитория в локальный.
- Перед созданием нового пул-реквеста считается хорошей практикой перейти в главную ветку, «подтянуть» в неё изменения, а затем добавить эти изменения в вашу ветку с помощью **git merge main**.

## Fast Forward
Две ветки находятся в состоянии fast-forward, если одну из них можно «перемотать» вперёд и она будет содержать те же коммиты, что и другая. Это утверждение можно сформулировать иначе:

- при слиянии этих двух веток никак не возможен конфликт;
- истории этих двух веток не «разошлись»;
- одна ветка является продолжением другой.

Fast-forward слияние веток можно отключить флагом **--no-ff**. Например: **git merge --no-ff add-docs**. Также его можно отключить «навсегда» (до тех пор, пока вы не вернёте настройку «как было») с помощью настройки *merge.ff*: **git config [--global] merge.ff false**.

Если отключить слияние в режиме fast-forward, вместо «перемотки» ветки Git создаст в ней коммит слияния (англ. merge commit) — в обиходе его называют merge-коммит или мёрж-коммит.

Многие проекты отключают fast-forward слияние веток, потому что при нём теряется часть информации. Результат выглядит так, как будто в main «просто появились» новые коммиты. Если не знать о ветке add-docs, то можно подумать, что такой ветки и не было. Полноценный коммит слияния сохраняет всю информацию: в нём будет указано, какая именно ветка вливалась в main.
