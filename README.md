# GIT Cheat Sheet

## Создание репозитория
- Инициализировать репозиторий можно с помощью команды **git init**.
- Проверить статус, или состояние, репозитория поможет команда **git status**.
- Если вы ошиблись и случайно инициализировали не ту папку, можно «разгитить» её — удалить скрытую подпапку **.git**.

## Добавление файлов в репозиторий
- Команда **git add** позволяет подготовить файл к сохранению.
- Команда **git add --all** подготовит к сохранению сразу все файлы.
- С помощью **git add .** можно добавить в репозиторий текущую папку со всеми файлами.

## GIT Commit
- Коммит можно сделать с помощью команды *git commit*.
- Ключ **-m** позволяет присвоить коммиту сообщение. Помните, что такие сообщения должны быть информативными: чётко описывать изменения.
- В коммит попадает то, что было предварительно добавлено «в корзину», или «в кадр», перед коммитом.

## История коммитов
Для просмотра истории коммитов используют команду **git log** (от англ. log — «журнал»).

Получить сокращённый лог можно с помощью команды git log с флагом **--oneline** (англ. «одной строкой»). В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.

## SSH-ключ и его генерация
- *SSH* — протокол, который обеспечивает безопасный обмен данными в сети и использует для этого ключи.
- *SSH-ключ* — ваш виртуальный идентификатор в GitHub. Как ключ от квартиры, он позволяет получить доступ к GitHub-репозиторию. Также SSH используется для доступа к другим удалённым серверам.
- *SSH-ключ состоит из двух частей* — публичной и приватной. Публичный ключ зашифрует данные, а приватный — расшифрует. Приватным ключом ни в коем случае нельзя делиться, иначе любой сможет расшифровать все ваши секреты!

Для генерации SSH-ключа используют команды:

**$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"**

или

**$ ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"**


После создания SSH-ключа его необходимо привязать к аккаунту GitHub, [здесь](https://practicum.yandex.ru/trainer/git-basics/lesson/4d662a58-3602-4c5c-9fad-be8cff334f37/) можно посмотреть инструкцию.

## Связка локального и удаленного репозиториев
Чтобы привязать удаленный репозиторий к локальному, используют команду **git remote add**. Пример использования команды:

**$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git** ,

где *origin* - (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один), а *git@github.com:%ИМЯ_АККАУНТА%/first-project.git* - SSH-ссылка на удаленный репозиторий.

Для проверки связки репозиториев используется команда **git remote -v**.

*$ git remote -v*
*origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)*
*origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)*

Вывод должен быть аналогичен, указанному выше.

Флаг *-v* — короткая форма флага *--verbose* (англ. «подробный»). Он позволяет показать больше информации в выводе.

## Синхронизация локального и удаленного репозиториев
За отправку изменений на удалённый репозиторий отвечает команда **git push**. В первый раз эту команду нужно вызвать с флагом *-u* и параметрами *origin* (имя удалённого репозитория) и *main* или *master* (название текущей ветки). Флаг *-u* свяжет локальную ветку с одноимённой удалённой.

**$ git push -u origin main** *# Если команда приведёт к ошибке, попробуйте*
                              *# заменить main на master.*

В дальнейшем при работе с удалённым репозиторием флаг *-u* можно опустить и писать просто **git push**.

## Оформление файла README.md
Как правило, в **README.md** проекта можно найти следующую информацию:
- Название проекта и его краткое описание: кем создан, для чего, какие решает задачи и какие закрывает проблемы.
- Технологии, которые применяются в проекте. В чём его отличие от аналогичных.
- Документация проекта — подробная инструкция о том, что представляет собой проект.
- Планы проекта, если они есть.

Вот *пример файла README.md* для Git [на GitHub](https://github.com/git/git/blob/master/README.md).

**Преимущество README.md** в том, что средства командной работы (такие, как GitHub) могут отображать его содержимое в браузере в виде удобной разметки. Для этого нужно не просто залить текст, но и настроить шрифт, заголовки и отступы с помощью markdown. **Маркда́ун** — это специальный язык разметки. Он позволяет красиво отформатировать текстовый документ. Базовый синтаксис языка можно посмотреть [здесь](https://doka.guide/tools/markdown/).

## Хеш — идентификатор коммита
- Git преобразует информацию о коммитах с помощью алгоритма *SHA-1* и для каждого из них рассчитывает уникальный идентификатор — *хеш*.
- *Хеш* — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов.
- Все хеши, а также таблицу соответствий *хеш → информация* о коммите Git хранит в папке *.git*.

В числе прочих файлов в папке *.git* есть служебный файл **HEAD**. Он указывает на самый свежий коммит. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово **HEAD** — Git поймёт, что вы имели в виду последний коммит.

## Статусы файлов в Git
- Статусом **untracked** помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность **tracked**, в который попадают все файлы, отслеживаемые Git.
- Файл переходит в статус **staged** (синонимы - indexed и cached) после выполнения *git add*.
- Статус **modified** означает, что файл был изменён.
- Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.

## Правила по оформлению сообщений к коммитам

- **Краткость и ясность**: Сообщение коммита должно быть кратким и содержательным. Оно должно ясно передавать суть внесенных изменений.
- **Используйте повелительное наклонение**: Начните сообщение с глагола в повелительном наклонении. Например, "Add", "Fix", "Update", "Remove" и т.д. Это поможет ясно указать, что делает этот коммит.
- **Не используйте завершающие точки**: Они не нужны и могут создать несогласованность с другими сообщениями коммитов.
- **Описывайте изменения**: После заголовка, добавьте пустую строку, а затем короткое описание того, что именно было изменено. Это может быть необязательно, но если изменение не очевидно из заголовка, полезно добавить дополнительное пояснение.
- **Ссылка на задачу** (если есть): Если ваш проект использует систему управления задачами (например, Jira, Trello, GitHub Issues), хорошей практикой является добавление ссылки на соответствующую задачу в сообщение коммита. Например: "Add feature X (fixes #123)".
- **Избегайте коммитов слишком большого объема**: Лучше разбивать большие изменения на несколько более мелких и независимых коммитов. Это делает историю изменений более читаемой и позволяет более легко откатывать или возвращаться к определенным изменениям.
- **Используйте настоящее время**: Сообщение коммита должно описывать изменения так, будто они уже внесены, используя настоящее время.
- **Избегайте лишних деталей**: В сообщении коммита не следует добавлять слишком много деталей, которые не имеют отношения к сути изменений.

Более подробные требования к оформлению сообщений к коммитам можно посмотреть [здесь](https://practicum.yandex.ru/trainer/git-basics/lesson/1add1d42-16f2-4df3-b230-d3362e10acb8/).

## Исправление последнего коммита
Можно внести правки в уже сделанный коммит с помощью опции **--amend** (от англ. amend — «исправить», «дополнить») у команды *commit*: **git commit --amend**.

Важно: опция **--amend** работает только с последним коммитом (*HEAD*). Для исправления более ранних коммитов есть другие команды.

Дополнить коммит новыми файлами можно с помощью **git commit --amend --no-edit**. Благодаря опции **--no-edit** сообщение к коммиту останется таким, каким и было.

Изменить сообщение к коммиту позволяет команда **git commit --amend -m "Обновлённое сообщение коммита"**.

## Откат файлов и коммитов до более ранних версий
Команда **git restore --staged "имя файла"** переведёт файл из *staged* обратно в *modified* или *untracked*.

Команда **git reset --hard "commit hash"** «откатит» историю до коммита с хешем **"hash"**. Более поздние коммиты будут безвозвратно удалены.

Команда **git restore "имя файла"** «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии.
